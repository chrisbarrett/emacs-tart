;; Type signatures for Emacs cl-lib.el
;;
;; Source: emacs/lisp/emacs-lisp/cl-lib.el
;; Emacs version: 31.0
;;
;; Common Lisp compatibility library.

;; ===========================================================================
;; Loop macro
;; ===========================================================================

;; (cl-loop CLAUSE...) - Common Lisp loop macro
(defun cl-loop (&rest any) -> any)

;; ===========================================================================
;; Function definition
;; ===========================================================================

;; (cl-defun NAME ARGLIST BODY...) - define function with CL arglist
(defun cl-defun (symbol (list any) &rest any) -> symbol)

;; (cl-defmacro NAME ARGLIST BODY...) - define macro with CL arglist
(defun cl-defmacro (symbol (list any) &rest any) -> symbol)

;; ===========================================================================
;; Local function binding
;; ===========================================================================

;; (cl-flet ((FUNC ARGLIST BODY...) ...) FORM...)
;; Make local function definitions (non-recursive)
(defun cl-flet ((list any) &rest any) -> any)

;; (cl-labels ((FUNC ARGLIST BODY...) ...) FORM...)
;; Make local recursive function definitions
(defun cl-labels ((list any) &rest any) -> any)

;; (cl-letf ((PLACE VALUE) ...) BODY...) - temporarily bind places
(defun cl-letf ((list any) &rest any) -> any)

;; ===========================================================================
;; Destructuring
;; ===========================================================================

;; (cl-destructuring-bind ARGS EXPR BODY...) - bind variables from expr
(defun cl-destructuring-bind ((list any) any &rest any) -> any)

;; ===========================================================================
;; Case/type dispatch
;; ===========================================================================

;; (cl-case EXPR (KEYLIST BODY...)...) - dispatch on value
(defun cl-case (any &rest any) -> any)

;; (cl-typecase EXPR (TYPE BODY...)...) - dispatch on type
(defun cl-typecase (any &rest any) -> any)

;; (cl-ecase EXPR (KEYLIST BODY...)...) - cl-case with error on no match
(defun cl-ecase (any &rest any) -> any)

;; (cl-etypecase EXPR (TYPE BODY...)...) - cl-typecase with error on no match
(defun cl-etypecase (any &rest any) -> any)

;; ===========================================================================
;; Block/return
;; ===========================================================================

;; (cl-block NAME BODY...) - define lexically-scoped block
(defun cl-block (symbol &rest any) -> any)

;; (cl-return &optional RESULT) - return from nil block
(defun cl-return (&optional any) -> any)

;; (cl-return-from NAME &optional RESULT) - return from named block
(defun cl-return-from (symbol &optional any) -> any)

;; ===========================================================================
;; Modification macros
;; ===========================================================================

;; (cl-incf PLACE &optional X) - increment place by X (default 1)
(defun cl-incf (any &optional num) -> num)

;; (cl-decf PLACE &optional X) - decrement place by X (default 1)
(defun cl-decf (any &optional num) -> num)

;; (cl-pushnew X PLACE &key :test :test-not :key)
;; Add X to list in PLACE if not already present
(defun cl-pushnew [a] (a any &rest any) -> (list a))

;; ===========================================================================
;; List accessors
;; ===========================================================================

;; (cl-first LIST) - same as car
(defun cl-first [a] ((list a)) -> (a | nil))

;; (cl-second LIST) - car of cdr
(defun cl-second [a] ((list a)) -> (a | nil))

;; (cl-third LIST) - third element
(defun cl-third [a] ((list a)) -> (a | nil))

;; (cl-fourth LIST) through (cl-tenth LIST) - nth element
(defun cl-fourth [a] ((list a)) -> (a | nil))
(defun cl-fifth [a] ((list a)) -> (a | nil))
(defun cl-sixth [a] ((list a)) -> (a | nil))
(defun cl-seventh [a] ((list a)) -> (a | nil))
(defun cl-eighth [a] ((list a)) -> (a | nil))
(defun cl-ninth [a] ((list a)) -> (a | nil))
(defun cl-tenth [a] ((list a)) -> (a | nil))

;; (cl-rest LIST) - same as cdr
(defun cl-rest [a] ((list a)) -> (list a))

;; ===========================================================================
;; Higher-order functions
;; ===========================================================================

;; (cl-mapcar FUNCTION SEQ...) - map over multiple sequences
(defun cl-mapcar (((&rest any) -> any) &rest ((list any) | (vector any) | string)) -> (list any))

;; (cl-remove-if PRED LIST &key :key) - remove elements where pred is true
(defun cl-remove-if [a] (((a) -> any) (list a) &rest any) -> (list a))

;; (cl-remove-if-not PRED LIST &key :key) - keep elements where pred is true
(defun cl-remove-if-not [a] (((a) -> any) (list a) &rest any) -> (list a))

;; (cl-find-if PRED SEQ &key :key) - find first element where pred is true
(defun cl-find-if [a] (((a) -> any) ((list a) | (vector a) | string) &rest any) -> (a | nil))

;; (cl-position-if PRED SEQ &key :key) - find position where pred is true
(defun cl-position-if (((any) -> any) ((list any) | (vector any) | string) &rest any) -> (int | nil))

;; (cl-count-if PRED SEQ &key :key) - count elements where pred is true
(defun cl-count-if (((any) -> any) ((list any) | (vector any) | string) &rest any) -> int)

;; (cl-every PRED SEQ &rest MORE-SEQS) - true if pred true for all
(defun cl-every (((&rest any) -> any) &rest ((list any) | (vector any) | string)) -> bool)

;; (cl-some PRED SEQ &rest MORE-SEQS) - return first non-nil pred result
(defun cl-some (((&rest any) -> any) &rest ((list any) | (vector any) | string)) -> any)

;; (cl-notany PRED SEQ &rest MORE-SEQS) - true if pred false for all
(defun cl-notany (((&rest any) -> any) &rest ((list any) | (vector any) | string)) -> bool)

;; (cl-notevery PRED SEQ &rest MORE-SEQS) - true if pred false for some
(defun cl-notevery (((&rest any) -> any) &rest ((list any) | (vector any) | string)) -> bool)

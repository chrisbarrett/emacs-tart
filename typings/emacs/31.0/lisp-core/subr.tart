;; Type signatures for Emacs subr.el
;;
;; Source: emacs/lisp/subr.el
;; Emacs version: 31.0
;;
;; Core macros and utility functions. These are loaded at Emacs startup
;; and are available in all Emacs Lisp code.

;; ===========================================================================
;; Control flow macros
;; ===========================================================================

;; (when COND &rest BODY) - if COND is true, evaluate BODY
(defun when (any &rest any) -> any)

;; (unless COND &rest BODY) - if COND is nil, evaluate BODY
(defun unless (any &rest any) -> any)

;; (dolist (VAR LIST [RESULT]) &rest BODY) - iterate over list
(defun dolist (any &rest any) -> any)

;; (dotimes (VAR COUNT [RESULT]) &rest BODY) - iterate COUNT times
(defun dotimes (any &rest any) -> any)

;; ===========================================================================
;; Let-binding macros
;; ===========================================================================

;; (if-let SPEC THEN &rest ELSE) - conditional binding
(defun if-let (any any &rest any) -> any)

;; (if-let* VARLIST THEN &rest ELSE) - conditional multi-binding
(defun if-let* ((list any) any &rest any) -> any)

;; (when-let SPEC &rest BODY) - conditional binding that executes body
(defun when-let (any &rest any) -> any)

;; (when-let* VARLIST &rest BODY) - conditional multi-binding
(defun when-let* ((list any) &rest any) -> any)

;; (while-let SPEC &rest BODY) - while loop with binding
(defun while-let (any &rest any) -> any)

;; ===========================================================================
;; Buffer context macros
;; ===========================================================================

;; (with-current-buffer BUFFER &rest BODY) - execute body in buffer context
(defun with-current-buffer ((buffer | string) &rest any) -> any)

;; (with-temp-buffer &rest BODY) - execute body in temporary buffer
(defun with-temp-buffer (&rest any) -> any)

;; (with-output-to-string &rest BODY) - capture output as string
(defun with-output-to-string (&rest any) -> string)

;; (with-output-to-temp-buffer BUFNAME &rest BODY) - output to temp buffer
(defun with-output-to-temp-buffer (string &rest any) -> any)

;; (with-temp-file FILE &rest BODY) - execute body, write result to file
(defun with-temp-file (string &rest any) -> any)

;; ===========================================================================
;; Window/frame context macros
;; ===========================================================================

;; (with-selected-window WINDOW &rest BODY) - execute body with window selected
(defun with-selected-window (window &rest any) -> any)

;; (with-selected-frame FRAME &rest BODY) - execute body with frame selected
(defun with-selected-frame (frame &rest any) -> any)

;; ===========================================================================
;; State-saving macros
;; ===========================================================================

;; (save-match-data &rest BODY) - save/restore match data around body
(defun save-match-data (&rest any) -> any)

;; (with-silent-modifications &rest BODY) - suppress modification hooks
(defun with-silent-modifications (&rest any) -> any)

;; (with-undo-amalgamate &rest BODY) - combine undo entries
(defun with-undo-amalgamate (&rest any) -> any)

;; (with-local-quit &rest BODY) - allow C-g during body
(defun with-local-quit (&rest any) -> any)

;; (while-no-input &rest BODY) - abort on input
(defun while-no-input (&rest any) -> any)

;; (with-restriction START END &rest BODY) - restrict buffer to region
(defun with-restriction (int int &rest any) -> any)

;; ===========================================================================
;; Error handling macros
;; ===========================================================================

;; (with-demoted-errors FORMAT &rest BODY) - convert errors to messages
(defun with-demoted-errors (string &rest any) -> any)

;; ===========================================================================
;; Configuration macros
;; ===========================================================================

;; (with-case-table TABLE &rest BODY) - use case table during body
(defun with-case-table (any &rest any) -> any)

;; (with-file-modes MODES &rest BODY) - set default file modes during body
(defun with-file-modes (int &rest any) -> any)

;; (with-syntax-table TABLE &rest BODY) - use syntax table during body
(defun with-syntax-table (any &rest any) -> any)

;; (with-eval-after-load FILE &rest BODY) - evaluate body after file loads
(defun with-eval-after-load ((string | symbol) &rest any) -> nil)

;; (with-existing-directory &rest BODY) - ensure default-directory exists
(defun with-existing-directory (&rest any) -> any)

;; (with-temp-message MESSAGE &rest BODY) - show message during body
(defun with-temp-message ((string | nil) &rest any) -> any)

;; ===========================================================================
;; Error functions
;; ===========================================================================

;; (error STRING &rest ARGS) - signal error
(defun error (string &rest any) -> never)

;; (user-error FORMAT &rest ARGS) - signal user error
(defun user-error (string &rest any) -> never)

;; ===========================================================================
;; Number predicates
;; ===========================================================================

;; (zerop NUMBER) - test if number is zero
(defun zerop (num) -> bool)

;; (plusp NUMBER) - test if number is positive
(defun plusp (num) -> bool)

;; (minusp NUMBER) - test if number is negative
(defun minusp (num) -> bool)

;; (oddp INTEGER) - test if integer is odd
(defun oddp (int) -> bool)

;; (evenp INTEGER) - test if integer is even
(defun evenp (int) -> bool)

;; (fixnump OBJECT) - test if object is a fixnum
(defun fixnump (any) -> bool)

;; (bignump OBJECT) - test if object is a bignum
(defun bignump (any) -> bool)

;; ===========================================================================
;; List accessors (c*r functions)
;; ===========================================================================

;; (caar X) - (car (car x))
(defun caar [a b] ((pair (pair a any) any)) -> a)

;; (cadr X) - (car (cdr x))
(defun cadr [a] ((pair any (pair a any))) -> a)

;; (cdar X) - (cdr (car x))
(defun cdar [a b] ((pair (pair any a) any)) -> a)

;; (cddr X) - (cdr (cdr x))
(defun cddr [a] ((pair any (pair any a))) -> a)

;; Third and fourth level accessors - simplified to any
(defun caaar (any) -> any)
(defun caadr (any) -> any)
(defun cadar (any) -> any)
(defun caddr (any) -> any)
(defun cdaar (any) -> any)
(defun cdadr (any) -> any)
(defun cddar (any) -> any)
(defun cdddr (any) -> any)

;; ===========================================================================
;; Function utilities
;; ===========================================================================

;; (ignore &rest ARGUMENTS) - return nil ignoring arguments
(defun ignore (&rest any) -> nil)

;; (always &rest ARGUMENTS) - return t ignoring arguments
(defun always (&rest any) -> t)

;; (apply-partially FUN &rest ARGS) - partial application
(defun apply-partially (any &rest any) -> any)

;; (gensym &optional PREFIX) - generate unique symbol
(defun gensym (&optional string) -> symbol)

;; ===========================================================================
;; Bit operations
;; ===========================================================================

;; (lsh VALUE COUNT) - logical shift
(defun lsh (int int) -> int)

;; ===========================================================================
;; Buffer-local utilities
;; ===========================================================================

;; (buffer-local-boundp SYMBOL BUFFER) - test if var is buffer-local bound
(defun buffer-local-boundp (symbol buffer) -> bool)

;; (buffer-local-restore-state STATES) - restore buffer-local state
(defun buffer-local-restore-state ((list any)) -> nil)

;; ===========================================================================
;; Predicates
;; ===========================================================================

;; (frame-configuration-p OBJECT) - test if object is frame configuration
(defun frame-configuration-p (any) -> bool)

;; ===========================================================================
;; Error definition
;; ===========================================================================

;; (define-error NAME MESSAGE &optional PARENT) - define new error type
(defun define-error (symbol string &optional (symbol | (list symbol))) -> nil)

;; ===========================================================================
;; Hook management
;; ===========================================================================

;; (add-hook HOOK FN &optional DEPTH LOCAL) - add function to hook
(defun add-hook (symbol any &optional int bool) -> nil)

;; (remove-hook HOOK FN &optional LOCAL) - remove function from hook
(defun remove-hook (symbol any &optional bool) -> nil)

;; (run-hooks &rest HOOKS) - run multiple hooks
(defun run-hooks (&rest symbol) -> nil)

;; ===========================================================================
;; Stack-like list operations (macros)
;; ===========================================================================

;; (push NEWELT PLACE) - push element onto list variable
(defun push [a] (a any) -> (list a))

;; (pop PLACE) - pop and return first element of list variable
(defun pop [a] (any) -> a)

;; ===========================================================================
;; Buffer-local variable macros
;; ===========================================================================

;; (setq-local VAR VALUE) - set buffer-local variable
(defun setq-local (&rest any) -> any)

;; (defvar-local VAR &optional VALUE DOCSTRING) - define buffer-local variable
(defun defvar-local (symbol &optional any string) -> symbol)

;; ===========================================================================
;; String comparison (aliases)
;; ===========================================================================

;; (string= S1 S2) - alias for string-equal
(defun string= ((string | symbol) (string | symbol)) -> bool)

;; (string< S1 S2) - alias for string-lessp
(defun string< ((string | symbol) (string | symbol)) -> bool)

;; (string> S1 S2) - test if string greater than (in subr.el)
(defun string> ((string | symbol) (string | symbol)) -> bool)

;; ===========================================================================
;; Suppression macros
;; ===========================================================================

;; (with-no-warnings &rest BODY) - suppress compiler warnings
(defun with-no-warnings (&rest any) -> any)

;; ===========================================================================
;; Numeric utilities
;; ===========================================================================

;; (number-sequence FROM &optional TO INC) - generate list of numbers
(defun number-sequence (num &optional num num) -> (list num))

;; (clamp VALUE MIN MAX) - constrain value to range
(defun clamp (num num num) -> num)

;; ===========================================================================
;; String utilities
;; ===========================================================================

;; (string-empty-p STRING) - test if string is empty
(defun string-empty-p ((string | nil)) -> bool)

;; (string-blank-p STRING) - test if string is blank (only whitespace)
(defun string-blank-p ((string | nil)) -> bool)

;; (string-trim STRING &optional TRIM-LEFT TRIM-RIGHT) - trim whitespace
(defun string-trim (string &optional string string) -> string)

;; (string-trim-left STRING &optional REGEXP) - trim left whitespace
(defun string-trim-left (string &optional string) -> string)

;; (string-trim-right STRING &optional REGEXP) - trim right whitespace
(defun string-trim-right (string &optional string) -> string)

;; (string-prefix-p PREFIX STRING &optional IGNORE-CASE) - test prefix
(defun string-prefix-p (string string &optional bool) -> bool)

;; (string-suffix-p SUFFIX STRING &optional IGNORE-CASE) - test suffix
(defun string-suffix-p (string string &optional bool) -> bool)

;; (string-join STRINGS &optional SEPARATOR) - join strings with separator
(defun string-join ((list string) &optional string) -> string)

;; (string-replace FROM-STRING TO-STRING IN-STRING) - replace all occurrences
(defun string-replace (string string string) -> string)

;; (string-search NEEDLE HAYSTACK &optional START-POS) - find substring
(defun string-search (string string &optional int) -> (int | nil))

;; (split-string STRING &optional SEPARATORS OMIT-NULLS TRIM) - split string
(defun split-string (string &optional string bool string) -> (list string))

;; ===========================================================================
;; File/path utilities
;; ===========================================================================

;; (locate-library LIBRARY &optional NOSUFFIX PATH INTERACTIVE-CALL)
(defun locate-library (string &optional bool (list string) bool) -> (string | nil))

;; ===========================================================================
;; Miscellaneous predicates
;; ===========================================================================

;; (provide FEATURE &optional SUBFEATURES) - declare feature
(defun provide (symbol &optional (list symbol)) -> symbol)

;; (require FEATURE &optional FILENAME NOERROR) - load feature
(defun require (symbol &optional string bool) -> symbol)

;; (featurep FEATURE &optional SUBFEATURE) - test if feature is present
(defun featurep (symbol &optional symbol) -> bool)

;; ===========================================================================
;; List manipulation
;; ===========================================================================

;; (add-to-list LIST-VAR ELEMENT &optional APPEND COMPARE-FN) - add unique to list
(defun add-to-list (symbol any &optional bool any) -> (list any))

;; (alist-get KEY ALIST &optional DEFAULT REMOVE TESTFN) - get alist value
(defun alist-get [k v] (k (list (pair k v)) &optional v bool any) -> (v | nil))

;; (assq-delete-all KEY ALIST) - delete all entries with KEY using eq
(defun assq-delete-all [k v] (k (list (pair k v))) -> (list (pair k v)))

;; (assoc-delete-all KEY ALIST &optional TEST) - delete all entries with KEY
(defun assoc-delete-all [k v] (k (list (pair k v)) &optional any) -> (list (pair k v)))

;; (add-to-history HISTORY-VAR NEWELT &optional MAXELT KEEP-ALL) - add to history
(defun add-to-history (symbol any &optional int bool) -> (list any))

;; ===========================================================================
;; Event handling
;; ===========================================================================

;; (event-apply-modifier BASIC-EVENT MODIFIER) - add modifier to event
(defun event-apply-modifier (int symbol) -> int)

;; (event-modifiers EVENT) - get modifiers from event
(defun event-modifiers (any) -> (list symbol))

;; (event-basic-type EVENT) - get basic event type without modifiers
(defun event-basic-type (any) -> (int | symbol))

;; (event-start EVENT) - get start position of mouse event
(defun event-start (any) -> any)

;; (event-end EVENT) - get end position of mouse event
(defun event-end (any) -> any)

;; ===========================================================================
;; Function manipulation
;; ===========================================================================

;; (add-function WHERE PLACE FUNCTION &optional PROPS) - add advice
(defun add-function (symbol any any &optional any) -> nil)

;; (remove-function PLACE FUNCTION) - remove advice
(defun remove-function (any any) -> nil)

;; (advice-add SYMBOL WHERE FUNCTION &optional PROPS) - add advice to symbol
(defun advice-add (symbol symbol any &optional any) -> nil)

;; (advice-remove SYMBOL FUNCTION) - remove advice from symbol
(defun advice-remove (symbol any) -> nil)

;; (autoloadp OBJECT) - test if object is an autoload
(defun autoloadp (any) -> bool)

;; ===========================================================================
;; Documentation and key description
;; ===========================================================================

;; (substitute-command-keys STRING &optional NO-FACE) - replace \\=\\[...] with keys
(defun substitute-command-keys (string &optional bool) -> string)

;; (kbd KEYS) - convert key description to internal form
(defun kbd (string) -> any)

;; ===========================================================================
;; Minibuffer utilities (from subr.el)
;; ===========================================================================

;; (minibuffer-message STRING &rest ARGS) - display message in minibuffer
(defun minibuffer-message (string &rest any) -> nil)

;; ===========================================================================
;; Isearch
;; ===========================================================================

;; (isearch-forward &optional REGEXP-P NO-RECURSIVE-EDIT) - incremental search
(defun isearch-forward (&optional bool bool) -> nil)

;; (isearch-backward &optional REGEXP-P NO-RECURSIVE-EDIT) - reverse search
(defun isearch-backward (&optional bool bool) -> nil)

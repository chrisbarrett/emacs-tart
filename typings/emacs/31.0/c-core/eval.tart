;; Type signatures for Emacs eval.c
;;
;; Source: emacs/src/eval.c
;; Emacs version: 31.0
;;
;; Contains evaluation, control flow, and error handling primitives.
;;
;; Note: Many functions in eval.c are special forms that don't have
;; straightforward function types. We type them as best we can.

;; ===========================================================================
;; Special forms (control flow)
;; ===========================================================================

;; (quote ARG) - return argument unevaluated
;; Special form - can't be called as function
(defun quote [a] (a) -> a)

;; (function ARG) - like quote but marks as function
(defun function [a] (a) -> a)

;; (if COND THEN &rest ELSE) - conditional
;; The return type depends on which branch is taken
(defun if [a b] (any a &rest b) -> (a | b))

;; (cond &rest CLAUSES) - multi-branch conditional
(defun cond (&rest any) -> any)

;; (progn &rest BODY) - evaluate forms in sequence
(defun progn [a] (&rest a) -> a)

;; (prog1 FIRST &rest BODY) - evaluate and return first
(defun prog1 [a] (a &rest any) -> a)

;; (and &rest CONDITIONS) - short-circuit AND
(defun and (&rest any) -> any)

;; (or &rest CONDITIONS) - short-circuit OR
(defun or (&rest any) -> any)

;; (while TEST &rest BODY) - loop while true
(defun while (any &rest any) -> nil)

;; (let BINDINGS &rest BODY) - local bindings
(defun let [a] (any &rest a) -> a)

;; (let* BINDINGS &rest BODY) - sequential local bindings
(defun let* [a] (any &rest a) -> a)

;; ===========================================================================
;; Variable definitions
;; ===========================================================================

;; (setq &rest ARGS) - set variables
(defun setq (&rest any) -> any)

;; (defvar SYMBOL &optional INITVALUE DOCSTRING) - define variable
(defun defvar (symbol &optional any (string | nil)) -> symbol)

;; (defvar-1 SYMBOL INITVALUE DOCSTRING) - internal defvar
(defun defvar-1 (symbol any any) -> symbol)

;; (defconst SYMBOL INITVALUE &optional DOCSTRING) - define constant
(defun defconst (symbol any &optional (string | nil)) -> symbol)

;; (defconst-1 SYMBOL INITVALUE DOCSTRING) - internal defconst
(defun defconst-1 (symbol any any) -> symbol)

;; (defvaralias NEW-ALIAS BASE-VAR &optional DOCSTRING) - alias variable
(defun defvaralias (symbol symbol &optional (string | nil)) -> symbol)

;; (special-variable-p VAR) - test if special variable
(defun special-variable-p (symbol) -> bool)

;; ===========================================================================
;; Function application
;; ===========================================================================

;; (eval FORM &optional LEXICAL) - evaluate form
(defun eval (any &optional any) -> any)

;; (funcall FN &rest ARGS) - call function
;; Note: Return type depends on FN, typed as any
(defun funcall (any &rest any) -> any)

;; (apply FN &rest ARGS) - call with last arg as list
;; Note: Return type depends on FN, typed as any
(defun apply (any &rest any) -> any)

;; (funcall-with-delayed-message TIMEOUT MESSAGE FN &rest ARGS) - call with timeout message
(defun funcall-with-delayed-message (num string any &rest any) -> any)

;; (func-arity FN) - return (MIN . MAX) or (MIN . many)
;; Note: MAX is 'many symbol for variadic functions
(defun func-arity (any) -> (cons int (int | symbol)))

;; (functionp OBJ) - test if callable
(defun functionp (any) -> bool)

;; (commandp FN &optional FOR-CALL-INTERACTIVELY) - test if command
(defun commandp (any &optional any) -> bool)

;; (called-interactively-p KIND) - test if called interactively
;; KIND is 'interactive for M-x only, 'any for any interactive call
(defun called-interactively-p (symbol) -> bool)

;; (interactive-p) - legacy test for interactive call (deprecated)
(defun interactive-p () -> bool)

;; ===========================================================================
;; Macros
;; ===========================================================================

;; (macroexpand FORM &optional ENVIRONMENT) - expand macro
(defun macroexpand (any &optional any) -> any)

;; ===========================================================================
;; Autoload
;; ===========================================================================

;; (autoload FN FILE &optional DOCSTRING INTERACTIVE TYPE) - set up autoload
(defun autoload (symbol string &optional (string | nil) any any) -> symbol)

;; (autoload-do-load FN &optional MACRO-ONLY IMMEDIATE-LOAD) - load autoload
(defun autoload-do-load (any &optional any any) -> any)

;; ===========================================================================
;; Error handling
;; ===========================================================================

;; (signal ERROR DATA) - signal error condition
(defun signal (symbol any) -> never)

;; (condition-case VAR BODYFORM &rest HANDLERS) - catch errors
(defun condition-case (any any &rest any) -> any)

;; (handler-bind-1 HANDLERS-BODY) - internal handler binding
(defun handler-bind-1 (any) -> any)

;; (unwind-protect BODYFORM &rest UNWINDFORMS) - cleanup on exit
(defun unwind-protect [a] (a &rest any) -> a)

;; ===========================================================================
;; Non-local exits
;; ===========================================================================

;; (catch TAG &rest BODY) - establish catch point
(defun catch (any &rest any) -> any)

;; (throw TAG VALUE) - non-local return
(defun throw (any any) -> never)

;; ===========================================================================
;; Hooks
;; ===========================================================================

;; (run-hooks &rest HOOKS) - run normal hooks
(defun run-hooks (&rest symbol) -> nil)

;; (run-hook-with-args HOOK &rest ARGS) - run hook with arguments
(defun run-hook-with-args (symbol &rest any) -> any)

;; (run-hook-with-args-until-success HOOK &rest ARGS) - run until non-nil
(defun run-hook-with-args-until-success (symbol &rest any) -> any)

;; (run-hook-with-args-until-failure HOOK &rest ARGS) - run until nil
(defun run-hook-with-args-until-failure (symbol &rest any) -> any)

;; (run-hook-wrapped HOOK WRAP-FN &rest ARGS) - run with wrapper
(defun run-hook-wrapped (symbol any &rest any) -> any)

;; ===========================================================================
;; Closures
;; ===========================================================================

;; (make-interpreted-closure ARGS BODY ENV &optional DOCSTRING IFORM) - create closure
(defun make-interpreted-closure (any any any &optional any any) -> any)

;; ===========================================================================
;; Debugging
;; ===========================================================================

;; (backtrace-debug LEVEL FLAG) - set debug flag on frame
(defun backtrace-debug (int any) -> nil)

;; (backtrace-eval EXP NFRAMES &optional BASE) - eval in frame context
(defun backtrace-eval (any int &optional any) -> any)

;; (mapbacktrace FN &optional BASE) - map over backtrace
(defun mapbacktrace (any &optional any) -> nil)

;; (backtrace-frames &optional BASE) - collect all frames into a list
(defun backtrace-frames (&optional any) -> (list any))

;; (debugger-trap) - enter debugger
(defun debugger-trap () -> nil)

;; ===========================================================================
;; Internal/private functions
;; ===========================================================================

;; (backtrace--frames-from-thread THREAD) - internal: frames from thread
(defun backtrace--frames-from-thread (any) -> (vector any))

;; (backtrace--locals NFRAMES &optional BASE) - internal: local bindings
(defun backtrace--locals (int &optional any) -> any)

;; (backtrace-frame--internal NFRAMES &optional BASE) - internal: frame info
(defun backtrace-frame--internal (int &optional any) -> any)

;; (internal--define-uninitialized-variable SYMBOL &optional DOCSTRING) - internal
(defun internal--define-uninitialized-variable (symbol &optional any) -> symbol)

;; (internal-delete-indirect-variable VARIABLE) - internal
(defun internal-delete-indirect-variable (symbol) -> nil)

;; (internal-make-var-non-special VARIABLE) - internal
(defun internal-make-var-non-special (symbol) -> nil)

;; ===========================================================================
;; Toplevel values
;; ===========================================================================

;; (default-toplevel-value SYM) - get toplevel default
(defun default-toplevel-value (symbol) -> any)

;; (set-default-toplevel-value SYM VALUE) - set toplevel default
(defun set-default-toplevel-value (symbol any) -> nil)

;; (buffer-local-toplevel-value SYM &optional BUFFER) - get buffer toplevel
(defun buffer-local-toplevel-value (symbol &optional any) -> any)

;; (set-buffer-local-toplevel-value SYM VALUE &optional BUFFER) - set buffer toplevel
(defun set-buffer-local-toplevel-value (symbol any &optional any) -> nil)

;; Type signatures for Emacs fns.c
;;
;; Source: emacs/src/fns.c
;; Emacs version: 31.0
;;
;; Contains general utility functions: sequences, hash tables, strings.

;; ===========================================================================
;; Identity and equality
;; ===========================================================================

;; (identity ARG) - return argument unchanged
(defun identity [a] (arg : a) -> a)

;; (eql A B) - compare using eq for non-numbers, = for numbers
(defun eql (a b) -> bool)

;; (equal A B) - structural equality
(defun equal (a b) -> bool)

;; (equal-including-properties A B) - equality with text properties
(defun equal-including-properties (a b) -> bool)

;; ===========================================================================
;; Sequence operations
;; ===========================================================================

;; (length SEQ) - return length
(defun length (seq) -> int)

;; (safe-length LIST) - return length, handling cycles
(defun safe-length (list) -> int)

;; (length< SEQ LEN) - test if length less than
(defun length< (seq len : int) -> bool)

;; (length> SEQ LEN) - test if length greater than
(defun length> (seq len : int) -> bool)

;; (length= SEQ LEN) - test if length equal
(defun length= (seq len : int) -> bool)

;; (proper-list-p OBJ) - test if proper list
(defun proper-list-p (obj) -> (int | nil))

;; (elt SEQ N) - element at index
(defun elt [a] (seq n : int) -> a)

;; (copy-sequence SEQ) - shallow copy
(defun copy-sequence [a] (seq : a) -> a)

;; (reverse SEQ) - return reversed copy
(defun reverse [a] (seq : (list a)) -> (list a))

;; (nreverse SEQ) - destructive reverse
(defun nreverse [a] (seq : (list a)) -> (list a))

;; (sort SEQ PRED) - destructive sort
(defun sort [a] (seq : (list a) pred) -> (list a))

;; ===========================================================================
;; List operations
;; ===========================================================================

;; (nth N LIST) - nth element (0-indexed)
(defun nth [a] (n : int list : (list a)) -> (a | nil))

;; (nthcdr N LIST) - nth cdr of list
(defun nthcdr [a] (n : int list : (list a)) -> (list a))

;; (take N LIST) - take first n elements (non-destructive)
(defun take [a] (n : int list : (list a)) -> (list a))

;; (ntake N LIST) - take first n elements (destructive)
(defun ntake [a] (n : int list : (list a)) -> (list a))

;; (member ELT LIST) - find element using equal
(defun member [a] (elt list : (list a)) -> (list a))

;; (memq ELT LIST) - find element using eq
(defun memq [a] (elt list : (list a)) -> (list a))

;; (memql ELT LIST) - find element using eql
(defun memql [a] (elt list : (list a)) -> (list a))

;; (assoc KEY ALIST &optional TESTFN) - find by key using equal
(defun assoc [k v] (key alist : (list (pair k v)) &optional testfn) -> ((pair k v) | nil))

;; (assq KEY ALIST) - find by key using eq
(defun assq [k v] (key alist : (list (pair k v))) -> ((pair k v) | nil))

;; (rassoc VALUE ALIST) - find by value using equal
(defun rassoc [k v] (value alist : (list (pair k v))) -> ((pair k v) | nil))

;; (rassq VALUE ALIST) - find by value using eq
(defun rassq [k v] (value alist : (list (pair k v))) -> ((pair k v) | nil))

;; (delete ELT SEQ) - remove element using equal (destructive for lists)
(defun delete [a] (elt seq : (list a)) -> (list a))

;; (delq ELT LIST) - remove element using eq (destructive)
(defun delq [a] (elt list : (list a)) -> (list a))

;; (copy-alist ALIST) - shallow copy of alist
(defun copy-alist [k v] (alist : (list (pair k v))) -> (list (pair k v)))

;; ===========================================================================
;; List construction
;; ===========================================================================

;; (append &rest SEQS) - concatenate lists
(defun append [a] (&rest seqs : (list (list a))) -> (list a))

;; (concat &rest SEQS) - concatenate strings
(defun concat (&rest seqs : (list (string | (list any) | (vector any)))) -> string)

;; (vconcat &rest SEQS) - concatenate to vector
(defun vconcat (&rest seqs) -> (vector any))

;; (nconc &rest LISTS) - destructive append
(defun nconc [a] (&rest lists : (list (list a))) -> (list a))

;; ===========================================================================
;; Property list operations
;; ===========================================================================

;; (get SYM PROP &optional DEFAULT) - get symbol property
(defun get (sym : symbol prop : symbol &optional default) -> any)

;; (put SYM PROP VALUE) - set symbol property
(defun put (sym : symbol prop : symbol value) -> any)

;; (plist-get PLIST PROP &optional PREDICATE) - get from plist
(defun plist-get (plist : (list any) prop &optional predicate) -> any)

;; (plist-put PLIST PROP VALUE &optional PREDICATE) - put in plist
(defun plist-put (plist : (list any) prop value &optional predicate) -> (list any))

;; (plist-member PLIST PROP &optional PREDICATE) - check membership
(defun plist-member (plist : (list any) prop &optional predicate) -> (list any))

;; ===========================================================================
;; Mapping functions
;; ===========================================================================

;; (mapcar FN SEQ) - apply fn to each element
(defun mapcar [a b] (fn : (-> a b) seq : (list a)) -> (list b))

;; (mapc FN SEQ) - apply fn for side effects
(defun mapc [a] (fn seq : (list a)) -> (list a))

;; (mapcan FN SEQ) - mapcar then nconc results
(defun mapcan [a b] (fn : (-> a (list b)) seq : (list a)) -> (list b))

;; (mapconcat FN SEQ &optional SEP) - map and join with separator
(defun mapconcat [a] (fn : (-> a string) seq : (list a) &optional sep : (string | nil)) -> string)

;; ===========================================================================
;; Array operations
;; ===========================================================================

;; (fillarray ARRAY VALUE) - fill array with value
(defun fillarray [a] (array value : a) -> (vector a))

;; ===========================================================================
;; String operations
;; ===========================================================================

;; (substring STRING &optional FROM TO) - extract substring
(defun substring (string : string &optional from : (int | nil) to : (int | nil)) -> string)

;; (substring-no-properties STRING &optional FROM TO) - substring without props
(defun substring-no-properties (string : string &optional from : (int | nil) to : (int | nil)) -> string)

;; (string-equal S1 S2) - compare strings
(defun string-equal (s1 : (string | symbol) s2 : (string | symbol)) -> bool)

;; (string-lessp S1 S2) - lexicographic comparison
(defun string-lessp (s1 : (string | symbol) s2 : (string | symbol)) -> bool)

;; (string-version-lessp S1 S2) - version-aware comparison
(defun string-version-lessp (s1 : string s2 : string) -> bool)

;; (string-collate-lessp S1 S2 &optional LOCALE IGNORE-CASE) - locale-aware <
(defun string-collate-lessp (s1 : string s2 : string &optional locale ignore-case) -> bool)

;; (string-collate-equalp S1 S2 &optional LOCALE IGNORE-CASE) - locale-aware =
(defun string-collate-equalp (s1 : string s2 : string &optional locale ignore-case) -> bool)

;; (string-distance S1 S2 &optional BYTECOMPARE) - Levenshtein distance
(defun string-distance (s1 : string s2 : string &optional bytecompare) -> int)

;; (string-search NEEDLE HAYSTACK &optional START-POS) - find substring
(defun string-search (needle : string haystack : string &optional start-pos : (int | nil)) -> (int | nil))

;; (compare-strings S1 START1 END1 S2 START2 END2 &optional IGNORE-CASE)
(defun compare-strings (s1 : string start1 : (int | nil) end1 : (int | nil)
                        s2 : string start2 : (int | nil) end2 : (int | nil)
                        &optional ignore-case) -> (int | t))

;; (string-bytes STRING) - byte length
(defun string-bytes (string : string) -> int)

;; ===========================================================================
;; String encoding conversion
;; ===========================================================================

;; (string-as-unibyte STRING) - interpret as unibyte
(defun string-as-unibyte (string : string) -> string)

;; (string-as-multibyte STRING) - interpret as multibyte
(defun string-as-multibyte (string : string) -> string)

;; (string-make-unibyte STRING) - convert to unibyte
(defun string-make-unibyte (string : string) -> string)

;; (string-make-multibyte STRING) - convert to multibyte
(defun string-make-multibyte (string : string) -> string)

;; (string-to-unibyte STRING) - convert to unibyte
(defun string-to-unibyte (string : string) -> string)

;; (string-to-multibyte STRING) - convert to multibyte
(defun string-to-multibyte (string : string) -> string)

;; (clear-string STRING) - fill with nulls
(defun clear-string (string : string) -> nil)

;; ===========================================================================
;; Hash tables
;; ===========================================================================

;; (make-hash-table &rest ARGS) - create hash table
(defun make-hash-table (&rest args) -> (hashtable any any))

;; (hash-table-p OBJ) - test if hash table
(defun hash-table-p (obj) -> bool)

;; (gethash KEY TABLE &optional DEFAULT) - get value
(defun gethash [k v] (key : k table : (hashtable k v) &optional default : (v | nil)) -> (v | nil))

;; (puthash KEY VALUE TABLE) - put value
(defun puthash [k v] (key : k value : v table : (hashtable k v)) -> v)

;; (remhash KEY TABLE) - remove key
(defun remhash [k v] (key : k table : (hashtable k v)) -> nil)

;; (clrhash TABLE) - clear table
(defun clrhash [k v] (table : (hashtable k v)) -> (hashtable k v))

;; (maphash FN TABLE) - iterate over table
(defun maphash [k v] (fn table : (hashtable k v)) -> nil)

;; (copy-hash-table TABLE) - shallow copy
(defun copy-hash-table [k v] (table : (hashtable k v)) -> (hashtable k v))

;; (hash-table-count TABLE) - number of entries
(defun hash-table-count (table : (hashtable any any)) -> int)

;; (hash-table-size TABLE) - current capacity
(defun hash-table-size (table : (hashtable any any)) -> int)

;; (hash-table-test TABLE) - test function name
(defun hash-table-test (table : (hashtable any any)) -> symbol)

;; (hash-table-weakness TABLE) - weakness type
(defun hash-table-weakness (table : (hashtable any any)) -> (symbol | nil))

;; (hash-table-rehash-size TABLE) - rehash size
(defun hash-table-rehash-size (table : (hashtable any any)) -> float)

;; (hash-table-rehash-threshold TABLE) - rehash threshold
(defun hash-table-rehash-threshold (table : (hashtable any any)) -> float)

;; (define-hash-table-test NAME TEST HASH) - define custom test
(defun define-hash-table-test (name : symbol test hash) -> nil)

;; ===========================================================================
;; Hash functions
;; ===========================================================================

;; (sxhash-eq OBJ) - hash using eq
(defun sxhash-eq (obj) -> int)

;; (sxhash-eql OBJ) - hash using eql
(defun sxhash-eql (obj) -> int)

;; (sxhash-equal OBJ) - hash using equal
(defun sxhash-equal (obj) -> int)

;; (sxhash-equal-including-properties OBJ) - hash with text props
(defun sxhash-equal-including-properties (obj) -> int)

;; ===========================================================================
;; Value comparison
;; ===========================================================================

;; (value< A B) - generic comparison
(defun value< (a b) -> bool)

;; ===========================================================================
;; Features and requirements
;; ===========================================================================

;; (featurep FEATURE &optional SUBFEATURE) - test if feature present
(defun featurep (feature : symbol &optional subfeature : (symbol | nil)) -> bool)

;; (provide FEATURE &optional SUBFEATURES) - provide feature
(defun provide (feature : symbol &optional subfeatures : ((list symbol) | nil)) -> symbol)

;; (require FEATURE &optional FILENAME NOERROR) - require feature
(defun require (feature : symbol &optional filename : (string | nil) noerror) -> symbol)

;; ===========================================================================
;; Base64 encoding
;; ===========================================================================

;; (base64-encode-region START END &optional NO-LINE-BREAK) - encode region
(defun base64-encode-region (start end &optional no-line-break) -> int)

;; (base64-encode-string STRING &optional NO-LINE-BREAK) - encode string
(defun base64-encode-string (string : string &optional no-line-break) -> string)

;; (base64url-encode-region START END &optional NO-PAD) - URL-safe encode
(defun base64url-encode-region (start end &optional no-pad) -> int)

;; (base64url-encode-string STRING &optional NO-PAD) - URL-safe encode string
(defun base64url-encode-string (string : string &optional no-pad) -> string)

;; (base64-decode-region START END &optional BASE64URL IGNORE-INVALID) - decode
(defun base64-decode-region (start end &optional base64url ignore-invalid) -> int)

;; (base64-decode-string STRING &optional BASE64URL IGNORE-INVALID) - decode
(defun base64-decode-string (string : string &optional base64url ignore-invalid) -> (string | nil))

;; ===========================================================================
;; Cryptographic hashing
;; ===========================================================================

;; (md5 OBJ &optional START END CODING NOERROR) - MD5 hash
(defun md5 (obj &optional start end coding noerror) -> string)

;; (secure-hash ALGO OBJ &optional START END BINARY) - secure hash
(defun secure-hash (algo : symbol obj &optional start end binary) -> string)

;; (secure-hash-algorithms) - list available algorithms
(defun secure-hash-algorithms () -> (list symbol))

;; (buffer-hash &optional BUFFER-OR-NAME) - hash buffer contents
(defun buffer-hash (&optional buffer-or-name) -> string)

;; ===========================================================================
;; Text property intervals
;; ===========================================================================

;; (object-intervals OBJ) - get property intervals
(defun object-intervals (obj) -> (list any))

;; ===========================================================================
;; Random numbers
;; ===========================================================================

;; (random &optional LIMIT) - generate random number
(defun random (&optional limit : (int | t | nil)) -> int)

;; ===========================================================================
;; System information
;; ===========================================================================

;; (load-average &optional USE-FLOAT) - system load average
(defun load-average (&optional use-float) -> (list num))

;; (locale-info ITEM) - locale information
(defun locale-info (item : symbol) -> (string | nil))

;; ===========================================================================
;; Buffer statistics
;; ===========================================================================

;; (buffer-line-statistics &optional BUFFER POSITION) - line stats
(defun buffer-line-statistics (&optional buffer position) -> (vector int))

;; (line-number-at-pos &optional POS ABSOLUTE) - line number
(defun line-number-at-pos (&optional pos absolute) -> int)

;; ===========================================================================
;; User interaction
;; ===========================================================================

;; (yes-or-no-p PROMPT) - ask yes/no question
(defun yes-or-no-p (prompt : string) -> bool)

;; ===========================================================================
;; Internal functions
;; ===========================================================================

;; (internal--hash-table-buckets TABLE) - internal: get buckets
(defun internal--hash-table-buckets (table) -> (vector any))

;; (internal--hash-table-histogram TABLE) - internal: bucket histogram
(defun internal--hash-table-histogram (table) -> (vector int))

;; (internal--hash-table-index-size TABLE) - internal: index size
(defun internal--hash-table-index-size (table) -> int)

;; Type signatures for Emacs data.c
;;
;; Source: emacs/src/data.c
;; Emacs version: 31.0
;;
;; Contains fundamental predicates, accessors, and arithmetic.

;; ===========================================================================
;; Equality and identity
;; ===========================================================================

;; (eq A B) - identity comparison
;; eq compares by pointer identity. Safe for interned types (symbols,
;; keywords, small integers, t, nil). Unreliable for heap-allocated
;; types (strings, lists, floats). Disjointness is checked separately.
(defun eq
  ((eq-safe eq-safe) -> bool)
  ((_ _) -> bool
    (warn "eq compares by identity; use equal for structural comparison")))

;; (null OBJ) - test if nil
(defun null
  ((nil) -> t)
  ((_) -> nil))

;; ===========================================================================
;; Type predicates - return t or nil
;; ===========================================================================

;; Symbol predicates
(defun symbolp
  ((symbol) -> t)
  ((_) -> nil))
(defun keywordp
  ((keyword) -> t)
  ((_) -> nil))
(defun bare-symbol-p (any) -> bool)
(defun symbol-with-pos-p (any) -> bool)

;; Numeric predicates
(defun integerp
  ((int) -> t)
  ((_) -> nil))
(defun floatp
  ((float) -> t)
  ((_) -> nil))
(defun numberp
  ((num) -> t)
  ((_) -> nil))
(defun natnump
  ((int) -> bool)
  ((_) -> nil))
(defun number-or-marker-p
  ((num) -> t)
  ((marker) -> t)
  ((_) -> nil))
(defun integer-or-marker-p
  ((int) -> t)
  ((marker) -> t)
  ((_) -> nil))

;; List/cons predicates
(defun consp
  (((cons any any)) -> t)
  ((_) -> nil))
(defun atom
  (((cons any any)) -> nil)
  ((_) -> t))
(defun listp
  (((list any)) -> t)
  ((_) -> nil))
(defun nlistp
  (((list any)) -> nil)
  ((_) -> t))

;; Sequence predicates
(defun arrayp (any) -> bool)
(defun vectorp
  (((vector any)) -> t)
  ((_) -> nil))
(defun stringp
  ((string) -> t)
  ((_) -> nil))
(defun multibyte-string-p (any) -> bool)
(defun char-table-p (any) -> bool)
(defun vector-or-char-table-p (any) -> bool)
(defun bool-vector-p (any) -> bool)
(defun sequencep
  (((list any)) -> t)
  (((vector any)) -> t)
  ((string) -> t)
  ((_) -> nil))
(defun recordp (any) -> bool)

;; Other type predicates
(defun bufferp
  ((buffer) -> t)
  ((_) -> nil))
(defun markerp
  ((marker) -> t)
  ((_) -> nil))
(defun user-ptrp (any) -> bool)
(defun char-or-string-p
  ((int) -> t)
  ((string) -> t)
  ((_) -> nil))
(defun subrp (any) -> bool)
(defun byte-code-function-p (any) -> bool)
(defun interpreted-function-p (any) -> bool)
(defun closurep (any) -> bool)
(defun native-comp-function-p (any) -> bool)
(defun module-function-p (any) -> bool)
(defun threadp (any) -> bool)
(defun mutexp (any) -> bool)
(defun condition-variable-p (any) -> bool)

;; ===========================================================================
;; Type introspection
;; ===========================================================================

;; (type-of OBJ) - return type symbol
(defun type-of (any) -> symbol)

;; (cl-type-of OBJ) - CL-style type
(defun cl-type-of (any) -> symbol)

;; (subr-arity SUBR) - return (MIN . MAX) or (MIN . many)
(defun subr-arity (any) -> (cons int (int | symbol)))

;; (subr-name SUBR) - return symbol name
(defun subr-name (any) -> symbol)

;; (subr-type SUBR) - return function type
(defun subr-type (any) -> any)

;; ===========================================================================
;; Cons cell operations
;; ===========================================================================

;; (car LIST) - first element, nil if not a cons
;; Two clauses: list for normal usage, any fallback for union-typed values
;; from dynamic control flow (emits info note when precision is lost).
(defun car [a]
  (((list a)) -> (a | nil))
  ((any) -> any
    (note "car applied to non-list type; result is any")))

;; (cdr LIST) - rest of list, nil if not a cons
;; Same two-clause pattern as car.
(defun cdr [a]
  (((list a)) -> (list a))
  ((any) -> any
    (note "cdr applied to non-list type; result is any")))

;; (car-safe OBJ) - car or nil if not a cons
(defun car-safe [a b]
  (((cons a b)) -> a)
  ((_) -> nil))

;; (cdr-safe OBJ) - cdr or nil if not a cons
(defun cdr-safe [a b]
  (((cons a b)) -> b)
  ((_) -> nil))

;; (setcar CELL NEWCAR) - destructive update
;; Accepts (list a) in addition to (cons b c) because a non-empty list
;; is a cons cell, and callers frequently pass (nthcdr ...) results.
(defun setcar [a b c]
  (((cons b c) a) -> a)
  (((list a) a) -> a))

;; (setcdr CELL NEWCDR) - destructive update
;; Accepts (list a) in addition to (cons b c) for the same reason.
(defun setcdr [a b c]
  (((cons b c) a) -> a)
  (((list a) a) -> a))

;; ===========================================================================
;; Array operations
;; ===========================================================================

;; (aref ARRAY INDEX) - element access
;; Works on vectors, strings, char-tables, bool-vectors
(defun aref [a]
  (((vector a) int) -> a)
  ((string int) -> int))

;; (aset ARRAY INDEX VALUE) - element mutation
(defun aset [a]
  (((vector a) int a) -> a)
  ((string int int) -> int))

;; ===========================================================================
;; Symbol operations
;; ===========================================================================

;; (symbol-name SYM) - return name as string
(defun symbol-name (symbol) -> string)

;; (symbol-value SYM) - return current value
(defun symbol-value (symbol) -> any)

;; (symbol-function SYM) - return function binding
(defun symbol-function (symbol) -> any)

;; (symbol-plist SYM) - return property list
(defun symbol-plist (symbol) -> (list any))

;; (setplist SYM PLIST) - set property list
(defun setplist (symbol (list any)) -> (list any))

;; (boundp SYM) - test if variable is bound
(defun boundp (symbol) -> bool)

;; (fboundp SYM) - test if function is bound
(defun fboundp (symbol) -> bool)

;; (fset SYM DEF) - set function binding
(defun fset (symbol any) -> any)

;; (defalias SYM DEF &optional DOC) - define function alias
(defun defalias (symbol any &optional (string | nil)) -> symbol)

;; (set SYM VALUE) - set symbol value
(defun set (symbol any) -> any)

;; (makunbound SYM) - remove variable binding
(defun makunbound (symbol) -> symbol)

;; (fmakunbound SYM) - remove function binding
(defun fmakunbound (symbol) -> symbol)

;; (default-value SYM) - return default value
(defun default-value (symbol) -> any)

;; (default-boundp SYM) - test if default is bound
(defun default-boundp (symbol) -> bool)

;; (set-default SYM VALUE) - set default value
(defun set-default (symbol any) -> any)

;; ===========================================================================
;; Local variables
;; ===========================================================================

;; (make-local-variable SYM) - make buffer-local
(defun make-local-variable (symbol) -> symbol)

;; (kill-local-variable SYM) - remove buffer-local binding
(defun kill-local-variable (symbol) -> symbol)

;; (make-variable-buffer-local SYM) - make automatically buffer-local
(defun make-variable-buffer-local (symbol) -> symbol)

;; (local-variable-p SYM &optional BUFFER) - test if buffer-local
(defun local-variable-p (symbol &optional any) -> bool)

;; (local-variable-if-set-p SYM &optional BUFFER) - test if would be local
(defun local-variable-if-set-p (symbol &optional any) -> bool)

;; (variable-binding-locus SYM) - return buffer, frame, or nil
(defun variable-binding-locus (symbol) -> (buffer | frame | nil))

;; ===========================================================================
;; Indirect access
;; ===========================================================================

;; (indirect-function FN) - resolve symbol chain to function
(defun indirect-function (any) -> any)

;; (indirect-variable SYM) - resolve symbol chain to variable
(defun indirect-variable (symbol) -> symbol)

;; ===========================================================================
;; Function introspection
;; ===========================================================================

;; (interactive-form FN) - return interactive spec or nil
(defun interactive-form ((symbol | (any -> any))) -> ((list any) | nil))

;; (command-modes FN) - return command modes
(defun command-modes (any) -> (list symbol))

;; ===========================================================================
;; Arithmetic
;; ===========================================================================

;; (+ &rest NUMBERS) - addition
(defun + (&rest num) -> num)

;; (- N &rest NUMBERS) - subtraction or negation
(defun - (num &rest num) -> num)

;; (* &rest NUMBERS) - multiplication
(defun * (&rest num) -> num)

;; (/ N &rest DIVISORS) - division
(defun / (num &rest num) -> num)

;; (% N D) - modulo
(defun % (int int) -> int)

;; (mod N D) - modulo (always positive)
(defun mod (num num) -> num)

;; (1+ N) - increment
(defun 1+ (num) -> num)

;; (1- N) - decrement
(defun 1- (num) -> num)

;; (abs N) - absolute value
(defun abs (num) -> num)

;; (max N &rest NUMBERS) - maximum
(defun max (num &rest num) -> num)

;; (min N &rest NUMBERS) - minimum
(defun min (num &rest num) -> num)

;; ===========================================================================
;; Numeric comparison
;; ===========================================================================

;; (= N1 N2 &rest NS) - numeric equality
(defun = (num num &rest num) -> bool)

;; (< N1 N2 &rest NS) - less than
(defun < (num num &rest num) -> bool)

;; (> N1 N2 &rest NS) - greater than
(defun > (num num &rest num) -> bool)

;; (<= N1 N2 &rest NS) - less or equal
(defun <= (num num &rest num) -> bool)

;; (>= N1 N2 &rest NS) - greater or equal
(defun >= (num num &rest num) -> bool)

;; (/= N1 N2) - not equal
(defun /= (num num) -> bool)

;; ===========================================================================
;; Bitwise operations
;; ===========================================================================

;; (ash N COUNT) - arithmetic shift
(defun ash (int int) -> int)

;; (logand &rest INTS) - bitwise AND
(defun logand (&rest int) -> int)

;; (logior &rest INTS) - bitwise OR
(defun logior (&rest int) -> int)

;; (logxor &rest INTS) - bitwise XOR
(defun logxor (&rest int) -> int)

;; (lognot N) - bitwise NOT
(defun lognot (int) -> int)

;; (logcount N) - count 1 bits
(defun logcount (int) -> int)

;; ===========================================================================
;; Number conversion
;; ===========================================================================

;; (number-to-string N) - convert to string
(defun number-to-string (num) -> string)

;; (string-to-number S &optional BASE) - parse number
(defun string-to-number (string &optional (int | nil)) -> num)

;; (byteorder) - return byte order indicator
(defun byteorder () -> int)

;; ===========================================================================
;; Bool vector operations
;; ===========================================================================

;; (bool-vector-exclusive-or A B &optional C) - XOR bool vectors
;; When C given, stores result in C and returns C; otherwise allocates new.
(defun bool-vector-exclusive-or (bool-vector bool-vector &optional bool-vector) -> bool-vector)

;; (bool-vector-union A B &optional C) - OR bool vectors
(defun bool-vector-union (bool-vector bool-vector &optional bool-vector) -> bool-vector)

;; (bool-vector-intersection A B &optional C) - AND bool vectors
(defun bool-vector-intersection (bool-vector bool-vector &optional bool-vector) -> bool-vector)

;; (bool-vector-set-difference A B &optional C) - set difference
(defun bool-vector-set-difference (bool-vector bool-vector &optional bool-vector) -> bool-vector)

;; (bool-vector-not A &optional B) - NOT bool vector
(defun bool-vector-not (bool-vector &optional bool-vector) -> bool-vector)

;; (bool-vector-subsetp A B) - subset test
(defun bool-vector-subsetp (bool-vector bool-vector) -> bool)

;; (bool-vector-count-consecutive A B I) - count consecutive
(defun bool-vector-count-consecutive (bool-vector bool-vector int) -> int)

;; (bool-vector-count-population A) - count true values
(defun bool-vector-count-population (bool-vector) -> int)

;; ===========================================================================
;; Variable watchers
;; ===========================================================================

;; (add-variable-watcher SYM FN) - add watcher
(defun add-variable-watcher (symbol any) -> nil)

;; (remove-variable-watcher SYM FN) - remove watcher
(defun remove-variable-watcher (symbol any) -> nil)

;; (get-variable-watchers SYM) - get watchers
(defun get-variable-watchers (symbol) -> (list any))

;; ===========================================================================
;; Symbol position operations
;; ===========================================================================

;; (bare-symbol SYM) - remove position info
(defun bare-symbol (symbol) -> symbol)

;; (position-symbol SYM POS) - add position info
(defun position-symbol (symbol int) -> symbol)

;; (remove-pos-from-symbol SYM) - remove position info (alias)
(defun remove-pos-from-symbol (symbol) -> symbol)

;; (symbol-with-pos-pos SYM) - get position
(defun symbol-with-pos-pos (symbol) -> int)

;; ===========================================================================
;; Native compilation introspection
;; ===========================================================================

;; (subr-native-comp-unit SUBR) - get compilation unit
(defun subr-native-comp-unit (any) -> any)

;; (subr-native-lambda-list SUBR) - get lambda list
(defun subr-native-lambda-list (any) -> (list any))

;; (native-comp-unit-file UNIT) - get file path
(defun native-comp-unit-file (any) -> (string | nil))

;; (native-comp-unit-set-file UNIT PATH) - set file path
(defun native-comp-unit-set-file (any any) -> nil)

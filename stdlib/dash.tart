;;; dash.tart --- Type signatures for dash.el

;; Maps - Apply function to each element
(defun -map [a b] (((a) -> b) (list a)) -> (list b))
(defun -map-when [a] (((a) -> truthy) ((a) -> a) (list a)) -> (list a))
(defun -map-first [a] (((a) -> truthy) ((a) -> a) (list a)) -> (list a))
(defun -map-last [a] (((a) -> truthy) ((a) -> a) (list a)) -> (list a))
(defun -map-indexed [a b] (((int a) -> b) (list a)) -> (list b))
(defun -annotate [a b] (((a) -> b) (list a)) -> (list (pair b a)))
(defun -splice [a] (((a) -> truthy) ((a) -> (list a)) (list a)) -> (list a))
(defun -splice-list [a] (((a) -> truthy) (list a) (list a)) -> (list a))
(defun -mapcat [a b] (((a) -> (list b)) (list a)) -> (list b))
(defun -copy (any) -> any)

;; Sublist selection - Filter and take elements
(defun -filter [a] (((a) -> truthy) (list a)) -> (list a))
(defun -select [a] (((a) -> truthy) (list a)) -> (list a))
(defun -remove [a] (((a) -> truthy) (list a)) -> (list a))
(defun -reject [a] (((a) -> truthy) (list a)) -> (list a))
(defun -remove-first [a] (((a) -> truthy) (list a)) -> (list a))
(defun -remove-last [a] (((a) -> truthy) (list a)) -> (list a))
(defun -remove-item [a] (a (list a)) -> (list a))
(defun -non-nil [a] ((list (a | nil))) -> (list a))
(defun -slice [a] ((list a) int &optional int int) -> (list a))
(defun -take [a] (int (list a)) -> (list a))
(defun -take-last [a] (int (list a)) -> (list a))
(defun -drop [a] (int (list a)) -> (list a))
(defun -drop-last [a] (int (list a)) -> (list a))
(defun -take-while [a] (((a) -> truthy) (list a)) -> (list a))
(defun -drop-while [a] (((a) -> truthy) (list a)) -> (list a))
(defun -butlast ((list any)) -> (list any))

;; List modification
(defun -keep [a b] (((a) -> (b | nil)) (list a)) -> (list b))
(defun -concat [a] (&rest (list a)) -> (list a))
(defun -flatten ((list any)) -> (list any))
(defun -flatten-n (int (list any)) -> (list any))
(defun -replace [a] (a a (list a)) -> (list a))
(defun -replace-first [a] (a a (list a)) -> (list a))
(defun -replace-last [a] (a a (list a)) -> (list a))
(defun -insert-at [a] (int a (list a)) -> (list a))
(defun -replace-at [a] (int a (list a)) -> (list a))
(defun -update-at [a] (int ((a) -> a) (list a)) -> (list a))
(defun -remove-at (int (list any)) -> (list any))
(defun -remove-at-indices ((list int) (list any)) -> (list any))

;; Reductions - Aggregate list into value
(defun -reduce-from [a b] (((b a) -> b) b (list a)) -> b)
(defun -reduce [a] (((a a) -> a) (list a)) -> a)
(defun -reduce-r-from [a b] (((a b) -> b) b (list a)) -> b)
(defun -reduce-r [a] (((a a) -> a) (list a)) -> a)
(defun -reductions-from [a b] (((b a) -> b) b (list a)) -> (list b))
(defun -reductions [a] (((a a) -> a) (list a)) -> (list a))
(defun -reductions-r-from [a b] (((a b) -> b) b (list a)) -> (list b))
(defun -reductions-r [a] (((a a) -> a) (list a)) -> (list a))
(defun -count [a] (((a) -> truthy) (list a)) -> int)
(defun -sum ((list num)) -> num)
(defun -running-sum ((list num)) -> (list num))
(defun -product ((list num)) -> num)
(defun -running-product ((list num)) -> (list num))
(defun -inits [a] ((list a)) -> (list (list a)))
(defun -tails [a] ((list a)) -> (list (list a)))
(defun -common-prefix [a] (&rest (list a)) -> (list a))
(defun -common-suffix [a] (&rest (list a)) -> (list a))
(defun -min ((list num)) -> num)
(defun -min-by [a] (((a a) -> bool) (list a)) -> a)
(defun -max ((list num)) -> num)
(defun -max-by [a] (((a a) -> bool) (list a)) -> a)

;; Unfolding - Build lists from seed
(defun -iterate [a] (((a) -> a) a int) -> (list a))
(defun -unfold [a b] (((a) -> (b | nil)) a) -> (list b))
(defun -repeat (int any) -> (list any))
(defun -cycle (int (list any)) -> (list any))

;; Predicates
(defun -any? [a] (((a) -> truthy) (list a)) -> bool)
(defun -some? [a] (((a) -> truthy) (list a)) -> bool)
(defun -all? [a] (((a) -> truthy) (list a)) -> bool)
(defun -every? [a] (((a) -> truthy) (list a)) -> bool)
(defun -none? [a] (((a) -> truthy) (list a)) -> bool)
(defun -only-some? [a] (((a) -> truthy) (list a)) -> bool)
(defun -contains? [a] ((list a) a) -> bool)
(defun -same-items? [a] ((list a) (list a)) -> bool)
(defun -is-prefix? [a] ((list a) (list a)) -> bool)
(defun -is-suffix? [a] ((list a) (list a)) -> bool)
(defun -is-infix? [a] ((list a) (list a)) -> bool)

;; Partitioning - Split lists into sublists
(defun -split-at [a] (int (list a)) -> (tuple (list a) (list a)))
(defun -split-with [a] (((a) -> truthy) (list a)) -> (tuple (list a) (list a)))
(defun -split-on [a] (a (list a)) -> (list (list a)))
(defun -split-when [a] (((a) -> truthy) (list a)) -> (list (list a)))
(defun -separate [a] (((a) -> truthy) (list a)) -> (tuple (list a) (list a)))
(defun -partition [a] (int (list a)) -> (list (list a)))
(defun -partition-all [a] (int (list a)) -> (list (list a)))
(defun -partition-in-steps [a] (int int (list a)) -> (list (list a)))
(defun -partition-all-in-steps [a] (int int (list a)) -> (list (list a)))
(defun -partition-by [a b] (((a) -> b) (list a)) -> (list (list a)))
(defun -partition-by-header [a] (((a) -> truthy) (list a)) -> (list (list a)))
(defun -partition-after-pred [a] (((a) -> truthy) (list a)) -> (list (list a)))
(defun -partition-before-pred [a] (((a) -> truthy) (list a)) -> (list (list a)))
(defun -partition-before-item [a] (a (list a)) -> (list (list a)))
(defun -partition-after-item [a] (a (list a)) -> (list (list a)))
(defun -group-by [a k] (((a) -> k) (list a)) -> (list (pair k (list a))))

;; Indexing
(defun -elem-index [a] (a (list a)) -> (int | nil))
(defun -elem-indices [a] (a (list a)) -> (list int))
(defun -find-index [a] (((a) -> truthy) (list a)) -> (int | nil))
(defun -find-last-index [a] (((a) -> truthy) (list a)) -> (int | nil))
(defun -find-indices [a] (((a) -> truthy) (list a)) -> (list int))
(defun -grade-up [a] (((a a) -> bool) (list a)) -> (list int))
(defun -grade-down [a] (((a a) -> bool) (list a)) -> (list int))

;; Set operations
(defun -union [a] ((list a) (list a)) -> (list a))
(defun -difference [a] ((list a) (list a)) -> (list a))
(defun -intersection [a] ((list a) (list a)) -> (list a))
(defun -powerset [a] ((list a)) -> (list (list a)))
(defun -permutations [a] ((list a)) -> (list (list a)))
(defun -distinct [a] ((list a)) -> (list a))

;; Other operations
(defun -rotate [a] (int (list a)) -> (list a))
(defun -repeat-n (int any) -> (list any))
(defun -cons* [a] (&rest a) -> (list a))
(defun -snoc [a] ((list a) a &rest a) -> (list a))
(defun -interpose [a] (a (list a)) -> (list a))
(defun -interleave [a] ((list a) &rest (list a)) -> (list a))
(defun -iota (int &optional int int) -> (list int))
(defun -zip-pair [a b] ((list a) (list b)) -> (list (pair a b)))
(defun -zip-lists [a] (&rest (list a)) -> (list (list a)))
(defun -zip-fill [a] (a &rest (list a)) -> (list (list a)))
(defun -unzip-lists [a] ((list (list a))) -> (list (list a)))
(defun -pad [a] (a &rest (list a)) -> (list (list a)))
(defun -table [a b] (((a) -> b) &rest (list a)) -> (list b))
(defun -table-flat [a b] (((a) -> b) &rest (list a)) -> (list b))
(defun -first [a] (((a) -> truthy) (list a)) -> (a | nil))
(defun -some [a b] (((a) -> (b | nil)) (list a)) -> (b | nil))
(defun -last [a] ((list a)) -> (a | nil))
(defun -first-item [a] ((list a)) -> (a | nil))
(defun -second-item [a] ((list a)) -> (a | nil))
(defun -third-item [a] ((list a)) -> (a | nil))
(defun -fourth-item [a] ((list a)) -> (a | nil))
(defun -fifth-item [a] ((list a)) -> (a | nil))
(defun -last-item [a] ((list a)) -> (a | nil))
(defun -sort [a] (((a a) -> bool) (list a)) -> (list a))
(defun -list (&rest any) -> (list any))
(defun -fix [a] (((a) -> a) a) -> a)

;; Side effects
(defun -each [a] ((list a) ((a) -> any)) -> (list a))
(defun -each-while [a] ((list a) ((a) -> truthy) ((a) -> any)) -> (list a))
(defun -each-indexed [a] ((list a) ((int a) -> any)) -> (list a))
(defun -each-r [a] ((list a) ((a) -> any)) -> (list a))
(defun -each-r-while [a] ((list a) ((a) -> truthy) ((a) -> any)) -> (list a))
(defun -dotimes (int ((int) -> any)) -> nil)

;; Destructive operations
(defun -!cdr ((list any)) -> (list any))

;; Tree operations
(defun -tree-seq (((any) -> truthy) ((any) -> (list any)) any) -> (list any))
(defun -tree-map [a b] (((a) -> b) any) -> any)
(defun -tree-map-nodes (((any) -> truthy) ((any) -> any) any) -> any)
(defun -tree-reduce (((any any) -> any) any) -> any)
(defun -tree-reduce-from (((any any) -> any) any any) -> any)
(defun -tree-mapreduce (((any) -> any) ((any any) -> any) any) -> any)
(defun -tree-mapreduce-from (((any) -> any) ((any any) -> any) any any) -> any)
(defun -clone (any) -> any)

;; Threading macros (declared for completeness, but these are macros)
;; -> ->> -as-> -some-> -some->>

;; Binding macros (declared for completeness, but these are macros)
;; -when-let -when-let* -if-let -if-let* -let -let* -lambda

;; Comparison
(defun -on [a b c] (((b) -> c) ((c c) -> a)) -> ((b b) -> a))
(defun -flip [a b c] (((a b) -> c)) -> ((b a) -> c))
(defun -const [a] (a) -> ((&rest any) -> a))
(defun -cut (&rest any) -> ((&rest any) -> any))
(defun -not (((any) -> truthy)) -> ((any) -> bool))
(defun -orfn (&rest ((any) -> truthy)) -> ((any) -> bool))
(defun -andfn (&rest ((any) -> truthy)) -> ((any) -> bool))
(defun -iteratefn [a] (((a) -> a) int) -> ((a) -> a))
(defun -fixfn [a] (((a) -> a) &optional ((a a) -> bool)) -> ((a) -> a))
(defun -prodfn (&rest ((&rest any) -> any)) -> ((&rest any) -> (list any)))
(defun -juxt (&rest ((any) -> any)) -> ((any) -> (list any)))
(defun -compose (&rest ((any) -> any)) -> ((any) -> any))
(defun -applify (((any) -> any)) -> (((list any)) -> any))
(defun -partial [a b c] (((a b) -> c) a) -> ((b) -> c))
(defun -rpartial [a b c] (((a b) -> c) b) -> ((a) -> c))
(defun -converge [a b] (((&rest b) -> a) &rest ((any) -> b)) -> ((any) -> a))

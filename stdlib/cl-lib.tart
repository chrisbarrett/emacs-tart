;;; cl-lib.tart --- Type signatures for cl-lib.el

;; List operations
(defun cl-first [a] ((list a)) -> (a | nil))
(defun cl-second [a] ((list a)) -> (a | nil))
(defun cl-third [a] ((list a)) -> (a | nil))
(defun cl-fourth [a] ((list a)) -> (a | nil))
(defun cl-fifth [a] ((list a)) -> (a | nil))
(defun cl-rest [a] ((list a)) -> (list a))
(defun cl-copy-list [a] ((list a)) -> (list a))
(defun cl-list* [a] (a &rest a) -> (list a))

;; Sequence operations
(defun cl-mapcar [a b] (((a) -> b) (list a) &rest (list any)) -> (list b))
(defun cl-maplist [a b] ((((list a)) -> b) (list a)) -> (list b))
(defun cl-mapc [a b] (((a) -> b) (list a)) -> (list a))
(defun cl-mapcan [a b] (((a) -> (list b)) (list a)) -> (list b))
(defun cl-reduce [a b] (((b a) -> b) (list a) &key :initial-value b :from-end bool) -> b)
(defun cl-remove [a] (a (list a) &key :test ((a a) -> bool) :key ((a) -> any) :count int :from-end bool) -> (list a))
(defun cl-remove-if [a] (((a) -> truthy) (list a) &key :key ((a) -> any) :count int :from-end bool) -> (list a))
(defun cl-remove-if-not [a] (((a) -> truthy) (list a) &key :key ((a) -> any) :count int :from-end bool) -> (list a))
(defun cl-delete [a] (a (list a) &key :test ((a a) -> bool) :key ((a) -> any) :count int :from-end bool) -> (list a))
(defun cl-delete-if [a] (((a) -> truthy) (list a) &key :key ((a) -> any) :count int :from-end bool) -> (list a))
(defun cl-delete-if-not [a] (((a) -> truthy) (list a) &key :key ((a) -> any) :count int :from-end bool) -> (list a))
(defun cl-member [a] (a (list a) &key :test ((a a) -> bool) :key ((a) -> any)) -> (list a))
(defun cl-member-if [a] (((a) -> truthy) (list a) &key :key ((a) -> any)) -> (list a))
(defun cl-find [a] (a (list a) &key :test ((a a) -> bool) :key ((a) -> any) :from-end bool) -> (a | nil))
(defun cl-find-if [a] (((a) -> truthy) (list a) &key :key ((a) -> any) :from-end bool) -> (a | nil))
(defun cl-find-if-not [a] (((a) -> truthy) (list a) &key :key ((a) -> any) :from-end bool) -> (a | nil))
(defun cl-position [a] (a (list a) &key :test ((a a) -> bool) :key ((a) -> any) :from-end bool) -> (int | nil))
(defun cl-position-if [a] (((a) -> truthy) (list a) &key :key ((a) -> any) :from-end bool) -> (int | nil))
(defun cl-count [a] (a (list a) &key :test ((a a) -> bool) :key ((a) -> any)) -> int)
(defun cl-count-if [a] (((a) -> truthy) (list a) &key :key ((a) -> any)) -> int)
(defun cl-every [a] (((a) -> truthy) (list a)) -> bool)
(defun cl-some [a] (((a) -> truthy) (list a)) -> (truthy | nil))
(defun cl-notany [a] (((a) -> truthy) (list a)) -> bool)
(defun cl-notevery [a] (((a) -> truthy) (list a)) -> bool)
(defun cl-substitute [a] (a a (list a) &key :test ((a a) -> bool) :key ((a) -> any) :count int :from-end bool) -> (list a))
(defun cl-nsubstitute [a] (a a (list a) &key :test ((a a) -> bool) :key ((a) -> any) :count int :from-end bool) -> (list a))

;; Association list operations
(defun cl-assoc [k v] (k (list (pair k v)) &key :test ((k k) -> bool) :key ((k) -> any)) -> ((pair k v) | nil))
(defun cl-assoc-if [k v] (((k) -> truthy) (list (pair k v))) -> ((pair k v) | nil))
(defun cl-rassoc [k v] (v (list (pair k v)) &key :test ((v v) -> bool) :key ((v) -> any)) -> ((pair k v) | nil))
(defun cl-rassoc-if [k v] (((v) -> truthy) (list (pair k v))) -> ((pair k v) | nil))
(defun cl-acons [k v] (k v (list (pair k v))) -> (list (pair k v)))

;; Sorting
(defun cl-sort [a] ((list a) ((a a) -> bool) &key :key ((a) -> any)) -> (list a))
(defun cl-stable-sort [a] ((list a) ((a a) -> bool) &key :key ((a) -> any)) -> (list a))
(defun cl-merge [a] ((list a) (list a) ((a a) -> bool)) -> (list a))

;; Set operations
(defun cl-union [a] ((list a) (list a) &key :test ((a a) -> bool) :key ((a) -> any)) -> (list a))
(defun cl-nunion [a] ((list a) (list a) &key :test ((a a) -> bool) :key ((a) -> any)) -> (list a))
(defun cl-intersection [a] ((list a) (list a) &key :test ((a a) -> bool) :key ((a) -> any)) -> (list a))
(defun cl-nintersection [a] ((list a) (list a) &key :test ((a a) -> bool) :key ((a) -> any)) -> (list a))
(defun cl-set-difference [a] ((list a) (list a) &key :test ((a a) -> bool) :key ((a) -> any)) -> (list a))
(defun cl-nset-difference [a] ((list a) (list a) &key :test ((a a) -> bool) :key ((a) -> any)) -> (list a))
(defun cl-set-exclusive-or [a] ((list a) (list a) &key :test ((a a) -> bool) :key ((a) -> any)) -> (list a))
(defun cl-subsetp [a] ((list a) (list a) &key :test ((a a) -> bool) :key ((a) -> any)) -> bool)
(defun cl-adjoin [a] (a (list a) &key :test ((a a) -> bool) :key ((a) -> any)) -> (list a))

;; Sequence slicing
(defun cl-subseq [a] ((list a) int &optional int) -> (list a))

;; Tree operations
(defun cl-copy-tree [a] (a) -> a)
(defun cl-tree-equal (any any &key :test ((any any) -> bool)) -> bool)

;; Property lists
(defun cl-getf [a] ((list any) symbol &optional a) -> (a | nil))

;; Numeric functions
(defun cl-floor (num &optional num) -> (tuple int num))
(defun cl-ceiling (num &optional num) -> (tuple int num))
(defun cl-truncate (num &optional num) -> (tuple int num))
(defun cl-round (num &optional num) -> (tuple int num))
(defun cl-rem (num num) -> num)
(defun cl-mod (num num) -> num)
(defun cl-parse-integer (string &key :radix int) -> int)
(defun cl-random (num &optional any) -> num)
(defun cl-gcd (&rest int) -> int)
(defun cl-lcm (&rest int) -> int)
(defun cl-isqrt (int) -> int)

;; List accessors (sixth through tenth)
(defun cl-sixth [a] ((list a)) -> (a | nil))
(defun cl-seventh [a] ((list a)) -> (a | nil))
(defun cl-eighth [a] ((list a)) -> (a | nil))
(defun cl-ninth [a] ((list a)) -> (a | nil))
(defun cl-tenth [a] ((list a)) -> (a | nil))

;; Additional list operations
(defun cl-list-length [a] ((list a)) -> (int | nil))
(defun cl-ldiff [a] ((list a) (list a)) -> (list a))
(defun cl-tailp [a] ((list a) (list a)) -> bool)
(defun cl-revappend [a] ((list a) (list a)) -> (list a))
(defun cl-nreconc [a] ((list a) (list a)) -> (list a))
(defun cl-butlast [a] ((list a) &optional int) -> (list a))
(defun cl-nbutlast [a] ((list a) &optional int) -> (list a))

;; Fill and replace operations
(defun cl-fill [a] ((list a) a &key :start int :end int) -> (list a))
(defun cl-replace [a] ((list a) (list a) &key :start1 int :end1 int :start2 int :end2 int) -> (list a))

;; Search operations
(defun cl-search [a] ((list a) (list a) &key :test ((a a) -> bool) :key ((a) -> any) :from-end bool :start1 int :end1 int :start2 int :end2 int) -> (int | nil))
(defun cl-mismatch [a] ((list a) (list a) &key :test ((a a) -> bool) :key ((a) -> any) :from-end bool :start1 int :end1 int :start2 int :end2 int) -> (int | nil))

;; Concatenation
(defun cl-concatenate [a] (symbol &rest (list a)) -> (list a))

;; Additional sequence operations
(defun cl-remove-duplicates [a] ((list a) &key :test ((a a) -> bool) :key ((a) -> any) :from-end bool :start int :end int) -> (list a))
(defun cl-delete-duplicates [a] ((list a) &key :test ((a a) -> bool) :key ((a) -> any) :from-end bool :start int :end int) -> (list a))
(defun cl-substitute-if [a] (a ((a) -> truthy) (list a) &key :key ((a) -> any) :count int :from-end bool) -> (list a))
(defun cl-substitute-if-not [a] (a ((a) -> truthy) (list a) &key :key ((a) -> any) :count int :from-end bool) -> (list a))
(defun cl-nsubstitute-if [a] (a ((a) -> truthy) (list a) &key :key ((a) -> any) :count int :from-end bool) -> (list a))
(defun cl-nsubstitute-if-not [a] (a ((a) -> truthy) (list a) &key :key ((a) -> any) :count int :from-end bool) -> (list a))

;; Place modification (these are generalized setf-able)
;; Note: cl-incf, cl-decf, cl-pushnew are macros that modify places
;; We type them as functions taking a number/list and returning the new value
(defun cl-incf (num &optional num) -> num)
(defun cl-decf (num &optional num) -> num)
(defun cl-pushnew [a] (a (list a) &key :test ((a a) -> bool) :key ((a) -> any)) -> (list a))

;; Predicate functions
(defun cl-oddp (int) -> bool)
(defun cl-evenp (int) -> bool)
(defun cl-minusp (num) -> bool)
(defun cl-plusp (num) -> bool)
(defun cl-digit-char-p (string &optional int) -> (int | nil))

;; Character functions
(defun cl-char-upcase (string) -> string)
(defun cl-char-downcase (string) -> string)
(defun cl-digit-char (int &optional int) -> (string | nil))

;; Floating point operations
(defun cl-float (num &optional num) -> float)
(defun cl-float-limits () -> nil)

;; Bit operations
(defun cl-logand (&rest int) -> int)
(defun cl-logior (&rest int) -> int)
(defun cl-logxor (&rest int) -> int)
(defun cl-lognot (int) -> int)
(defun cl-logandc1 (int int) -> int)
(defun cl-logandc2 (int int) -> int)
(defun cl-logorc1 (int int) -> int)
(defun cl-logorc2 (int int) -> int)
(defun cl-lognand (int int) -> int)
(defun cl-lognor (int int) -> int)
(defun cl-logeqv (&rest int) -> int)
(defun cl-logbitp (int int) -> bool)
(defun cl-logtest (int int) -> bool)
(defun cl-logcount (int) -> int)
(defun cl-ash (int int) -> int)

;; Additional alist operations
(defun cl-pairlis [k v] ((list k) (list v) &optional (list (pair k v))) -> (list (pair k v)))

;; Additional property list operations
(defun cl-get (symbol symbol &optional any) -> any)
(defun cl-remf ((list any) symbol) -> (list any))

;; Multiple value operations (return multiple values as list)
(defun cl-values (&rest any) -> any)
(defun cl-values-list ((list any)) -> any)
(defun cl-multiple-value-list (any) -> (list any))

;; Structure operations (generic accessors)
;; Note: cl-defstruct creates specific accessors like NAME-SLOT
;; These are generic structure utilities
(defun cl-struct-slot-info (symbol) -> (list any))
(defun cl-struct-slot-offset (symbol symbol) -> int)

;; Type checking
(defun cl-typep (any symbol) -> bool)

;; Additional misc
(defun cl-coerce [a] (any symbol) -> a)
(defun cl-equalp (any any) -> bool)
(defun cl-type-of (any) -> symbol)
(defun cl-make-random-state (&optional any) -> any)
(defun cl-random-state-p (any) -> bool)
(defun cl-subst [a] (a a a &key :test ((a a) -> bool) :key ((a) -> any)) -> a)
(defun cl-nsubst [a] (a a a &key :test ((a a) -> bool) :key ((a) -> any)) -> a)
(defun cl-sublis [k v] ((list (pair k v)) any &key :test ((k k) -> bool) :key ((any) -> k)) -> any)
(defun cl-nsublis [k v] ((list (pair k v)) any &key :test ((k k) -> bool) :key ((any) -> k)) -> any)
